import os
import io
import numpy as np
import pandas as pd
import streamlit as st
import plotly.express as px
from typing import Dict, Tuple

# Import the workflow so we can generate data if missing
from main import run_workflow

CSV_PATH = os.path.join("outputs", "transactions_with_labels.csv")
REPORT_PATH = os.path.join("outputs", "anomaly_report.txt")

# ------------------------------
# Page config
# ------------------------------
st.set_page_config(page_title="Blockchain Anomaly Dashboard", layout="wide")
st.title("Blockchain Transaction Anomaly Dashboard")
st.caption("Visualize transactions, anomalies, and model metrics.")

# ------------------------------
# Data loaders (cached)
# ------------------------------
@st.cache_data
def load_transactions(csv_path: str) -> pd.DataFrame:
    """Load labeled transactions from CSV."""
    return pd.read_csv(csv_path)

@st.cache_data
def load_metrics(report_path: str) -> Dict[str, Dict[str, float]]:
    """Parse precision/recall/F1 from the text report generated by main.py."""
    metrics: Dict[str, Dict[str, float]] = {}
    if not os.path.exists(report_path):
        return metrics
    with open(report_path, "r", encoding="utf-8") as f:
        lines = f.read().splitlines()
    for line in lines:
        if line.startswith("Isolation Forest:"):
            parts = line.split(":", 1)[1].strip().split(",")
            metrics["Isolation Forest"] = {k.split("=")[0].strip(): float(k.split("=")[1]) for k in parts}
        if line.startswith("Autoencoder     :"):
            parts = line.split(":", 1)[1].strip().split(",")
            metrics["Autoencoder"] = {k.split("=")[0].strip(): float(k.split("=")[1]) for k in parts}
    return metrics

# ------------------------------
# Sidebar filters
# ------------------------------
def render_sidebar(df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict[str, bool]]:
    """Render sidebar with sender filter and anomaly-only toggle, return filtered DataFrame."""
    st.sidebar.header("Filters")

    # Sender filter: allow selecting one or multiple senders. Use top-K frequent senders to keep the list manageable.
    top_sender_count = 200
    sender_counts = df["sender"].value_counts().head(top_sender_count)
    sender_options = sender_counts.index.astype(int).tolist()
    selected_senders = st.sidebar.multiselect(
        label="Filter by sender (top 200 by frequency)", options=sender_options, default=[]
    )

    show_only_anomalies = st.sidebar.checkbox("Show only anomalies", value=False)

    df_filtered = df.copy()
    if selected_senders:
        df_filtered = df_filtered[df_filtered["sender"].isin(selected_senders)]
    if show_only_anomalies:
        df_filtered = df_filtered[df_filtered["label_text"] == "anomaly"]

    meta = {"show_only_anomalies": show_only_anomalies, "selected_senders": bool(selected_senders)}
    return df_filtered, meta

# ------------------------------
# Sections
# ------------------------------
def section_preview(df: pd.DataFrame) -> None:
    st.markdown("### Transactions Preview")
    st.dataframe(df.head(10))


def section_metrics(metrics: Dict[str, Dict[str, float]]) -> None:
    st.markdown("### Model Metrics")
    if not metrics:
        st.info("Metrics not found. Run the generator below to create data and metrics.")
        return
    cols = st.columns(2)
    for i, (name, m) in enumerate(metrics.items()):
        with cols[i % 2]:
            st.metric(label=f"{name} Precision", value=f"{m.get('precision', 0):.4f}")
            st.metric(label=f"{name} Recall", value=f"{m.get('recall', 0):.4f}")
            st.metric(label=f"{name} F1", value=f"{m.get('f1', 0):.4f}")


def section_distribution(df: pd.DataFrame) -> None:
    st.markdown("### Anomaly Distribution")
    counts = df["label_text"].value_counts().rename_axis("label").reset_index(name="count")
    fig = px.bar(
        counts,
        x="label",
        y="count",
        color="label",
        color_discrete_map={"normal": "#4CAF50", "anomaly": "#F44336"},
        title="Normal vs Anomaly Count",
    )
    st.plotly_chart(fig, use_container_width=True)


def section_scatter(df: pd.DataFrame) -> None:
    st.markdown("### Amount vs Gas Fee")
    fig = px.scatter(
        df,
        x="amount",
        y="gas_fee",
        color="label_text",
        hover_data=["sender", "receiver", "timestamp", "amount_to_gas_ratio"],
        color_discrete_map={"normal": "#4CAF50", "anomaly": "#F44336"},
        opacity=0.85,
        title="Amount vs Gas Fee (Anomalies Highlighted)",
    )
    st.plotly_chart(fig, use_container_width=True)


def section_download(df: pd.DataFrame) -> None:
    st.markdown("### Download Labeled Transactions")
    csv_buf = io.StringIO()
    df.to_csv(csv_buf, index=False)
    st.download_button(
        label="Download CSV",
        data=csv_buf.getvalue(),
        file_name="transactions_with_labels_filtered.csv",
        mime="text/csv",
    )


def section_generate_if_missing() -> None:
    """UI to generate dataset if CSV is missing on the server."""
    st.markdown("### Generate Sample Data (if missing)")
    st.write(
        "The CSV and metrics are created by the training pipeline. Click generate to create them now."
    )
    col1, col2, col3 = st.columns(3)
    with col1:
        num_tx = st.number_input("num_tx", min_value=500, max_value=20000, value=5000, step=500)
    with col2:
        anomaly_ratio = st.slider("anomaly_ratio", min_value=0.005, max_value=0.1, value=0.03, step=0.005)
    with col3:
        random_state = st.number_input("random_state", min_value=0, max_value=10000, value=42, step=1)
    if st.button("Generate dataset"):
        # Run pipeline to create outputs including CSV and report
        run_workflow(
            num_tx=int(num_tx),
            anomaly_ratio=float(anomaly_ratio),
            random_state=int(random_state),
            iso_contamination=float(anomaly_ratio),
            ae_contamination=float(anomaly_ratio),
        )
        st.success("Dataset generated. Reloading...")
        st.rerun()

# ------------------------------
# Main app logic
# ------------------------------
if not os.path.exists(CSV_PATH):
    st.error(f"CSV not found at {CSV_PATH}.")
    section_generate_if_missing()
    st.stop()

# Load
df_all = load_transactions(CSV_PATH)
metrics = load_metrics(REPORT_PATH)

# Sidebar filters
df_view, _ = render_sidebar(df_all)

# Sections
section_preview(df_view)
section_metrics(metrics)
section_distribution(df_view)
section_scatter(df_view)
section_download(df_view)

st.caption("If the CSV is missing, use the generator above or run locally: `python main.py --num_tx 5000 --anomaly_ratio 0.03 --random_state 42`. Then redeploy or refresh.")
